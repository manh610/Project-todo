"use strict";
/**
 * todo
 * todo
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const querystring = require("querystring");
const url = require("url");
const isomorphicFetch = require("isomorphic-fetch");
const assign = require("core-js/library/fn/object/assign");
const BASE_PATH = "https://localhost/api".replace(/\/+$/, "");
class BaseAPI {
    constructor(fetch = isomorphicFetch, basePath = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 * AccountApi - fetch parameter creator
 */
exports.AccountApiFetchParamCreator = {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    accountChangePassword(params, options) {
        // verify required parameter "oldPassword" is set
        if (params["oldPassword"] == null) {
            throw new Error("Missing required parameter oldPassword when calling accountChangePassword");
        }
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountChangePassword");
        }
        const baseUrl = `/Accounts/change-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "oldPassword": params["oldPassword"],
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    accountConfirm(params, options) {
        // verify required parameter "uid" is set
        if (params["uid"] == null) {
            throw new Error("Missing required parameter uid when calling accountConfirm");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            throw new Error("Missing required parameter token when calling accountConfirm");
        }
        const baseUrl = `/Accounts/confirm`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "uid": params["uid"],
            "token": params["token"],
            "redirect": params["redirect"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params, options) {
        const baseUrl = `/Accounts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamGetAccountsChangeStream(params, options) {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamPostAccountsChangeStream(params, options) {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountDeleteById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsGetAccountsidExists");
        }
        const baseUrl = `/Accounts/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsHeadAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountFindById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params, options) {
        const baseUrl = `/Accounts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params, options) {
        // verify required parameter "credentials" is set
        if (params["credentials"] == null) {
            throw new Error("Missing required parameter credentials when calling accountLogin");
        }
        const baseUrl = `/Accounts/login`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "include": params["include"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["credentials"]) {
            fetchOptions.body = JSON.stringify(params["credentials"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Logout a user with access token.
     */
    accountLogout(options) {
        const baseUrl = `/Accounts/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/count`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts todos of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountTodos(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountTodos");
        }
        const baseUrl = `/Accounts/{id}/todos/count`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in todos of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateTodos(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateTodos");
        }
        const baseUrl = `/Accounts/{id}/todos`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all todos of this model.
     * @param id Account id
     */
    accountPrototypeDeleteTodos(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteTodos");
        }
        const baseUrl = `/Accounts/{id}/todos`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for todos.
     * @param id Account id
     * @param fk Foreign key for todos
     */
    accountPrototypeDestroyByIdTodos(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdTodos");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdTodos");
        }
        const baseUrl = `/Accounts/{id}/todos/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for todos.
     * @param id Account id
     * @param fk Foreign key for todos
     */
    accountPrototypeFindByIdTodos(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdTodos");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdTodos");
        }
        const baseUrl = `/Accounts/{id}/todos/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries todos of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetTodos(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetTodos");
        }
        const baseUrl = `/Accounts/{id}/todos`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypePatchAttributes");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    accountPrototypeUpdateByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for todos.
     * @param id Account id
     * @param fk Foreign key for todos
     * @param data
     */
    accountPrototypeUpdateByIdTodos(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdTodos");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdTodos");
        }
        const baseUrl = `/Accounts/{id}/todos/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeVerify");
        }
        const baseUrl = `/Accounts/{id}/verify`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPostAccountsidReplace");
        }
        const baseUrl = `/Accounts/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPutAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
        const baseUrl = `/Accounts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    accountResetPassword(params, options) {
        // verify required parameter "options" is set
        if (params["options"] == null) {
            throw new Error("Missing required parameter options when calling accountResetPassword");
        }
        const baseUrl = `/Accounts/reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    accountSetPassword(params, options) {
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountSetPassword");
        }
        const baseUrl = `/Accounts/reset-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params, options) {
        const baseUrl = `/Accounts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params, options) {
        const baseUrl = `/Accounts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * AccountApi - functional programming interface
 */
exports.AccountApiFp = {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    accountChangePassword(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountChangePassword(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    accountConfirm(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountConfirm(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamGetAccountsChangeStream(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCreateChangeStreamGetAccountsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamPostAccountsChangeStream(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCreateChangeStreamPostAccountsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountExistsGetAccountsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountExistsHeadAccountsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountLogin(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Logout a user with access token.
     */
    accountLogout(options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountLogout(options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts todos of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountTodos(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountTodos(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in todos of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateTodos(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateTodos(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all todos of this model.
     * @param id Account id
     */
    accountPrototypeDeleteTodos(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteTodos(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for todos.
     * @param id Account id
     * @param fk Foreign key for todos
     */
    accountPrototypeDestroyByIdTodos(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdTodos(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for todos.
     * @param id Account id
     * @param fk Foreign key for todos
     */
    accountPrototypeFindByIdTodos(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdTodos(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries todos of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetTodos(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetTodos(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    accountPrototypeUpdateByIdAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for todos.
     * @param id Account id
     * @param fk Foreign key for todos
     * @param data
     */
    accountPrototypeUpdateByIdTodos(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdTodos(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeVerify(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceByIdPostAccountsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceByIdPutAccountsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceOrCreatePutAccounts(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    accountResetPassword(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountResetPassword(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    accountSetPassword(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountSetPassword(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * AccountApi - object-oriented interface
 */
class AccountApi extends BaseAPI {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    accountChangePassword(params, options) {
        return exports.AccountApiFp.accountChangePassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    accountConfirm(params, options) {
        return exports.AccountApiFp.accountConfirm(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params, options) {
        return exports.AccountApiFp.accountCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params, options) {
        return exports.AccountApiFp.accountCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamGetAccountsChangeStream(params, options) {
        return exports.AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamPostAccountsChangeStream(params, options) {
        return exports.AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params, options) {
        return exports.AccountApiFp.accountDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params, options) {
        return exports.AccountApiFp.accountExistsGetAccountsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params, options) {
        return exports.AccountApiFp.accountExistsHeadAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params, options) {
        return exports.AccountApiFp.accountFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params, options) {
        return exports.AccountApiFp.accountFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params, options) {
        return exports.AccountApiFp.accountFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params, options) {
        return exports.AccountApiFp.accountLogin(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Logout a user with access token.
     */
    accountLogout(options) {
        return exports.AccountApiFp.accountLogout(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params, options) {
        return exports.AccountApiFp.accountPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeCountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts todos of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountTodos(params, options) {
        return exports.AccountApiFp.accountPrototypeCountTodos(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in todos of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateTodos(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateTodos(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all todos of this model.
     * @param id Account id
     */
    accountPrototypeDeleteTodos(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteTodos(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for todos.
     * @param id Account id
     * @param fk Foreign key for todos
     */
    accountPrototypeDestroyByIdTodos(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdTodos(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for todos.
     * @param id Account id
     * @param fk Foreign key for todos
     */
    accountPrototypeFindByIdTodos(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdTodos(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeGetAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries todos of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetTodos(params, options) {
        return exports.AccountApiFp.accountPrototypeGetTodos(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params, options) {
        return exports.AccountApiFp.accountPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    accountPrototypeUpdateByIdAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for todos.
     * @param id Account id
     * @param fk Foreign key for todos
     * @param data
     */
    accountPrototypeUpdateByIdTodos(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdTodos(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params, options) {
        return exports.AccountApiFp.accountPrototypeVerify(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params, options) {
        return exports.AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params, options) {
        return exports.AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
        return exports.AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params, options) {
        return exports.AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    accountResetPassword(params, options) {
        return exports.AccountApiFp.accountResetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    accountSetPassword(params, options) {
        return exports.AccountApiFp.accountSetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params, options) {
        return exports.AccountApiFp.accountUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params, options) {
        return exports.AccountApiFp.accountUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.AccountApi = AccountApi;
;
/**
 * AccountApi - factory interface
 */
exports.AccountApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Change a user's password.
         * @param oldPassword
         * @param newPassword
         */
        accountChangePassword(params, options) {
            return exports.AccountApiFp.accountChangePassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Confirm a user registration with identity verification token.
         * @param uid
         * @param token
         * @param redirect
         */
        accountConfirm(params, options) {
            return exports.AccountApiFp.accountConfirm(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountCount(params, options) {
            return exports.AccountApiFp.accountCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountCreate(params, options) {
            return exports.AccountApiFp.accountCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountCreateChangeStreamGetAccountsChangeStream(params, options) {
            return exports.AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountCreateChangeStreamPostAccountsChangeStream(params, options) {
            return exports.AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountDeleteById(params, options) {
            return exports.AccountApiFp.accountDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsGetAccountsidExists(params, options) {
            return exports.AccountApiFp.accountExistsGetAccountsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsHeadAccountsid(params, options) {
            return exports.AccountApiFp.accountExistsHeadAccountsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFind(params, options) {
            return exports.AccountApiFp.accountFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountFindById(params, options) {
            return exports.AccountApiFp.accountFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFindOne(params, options) {
            return exports.AccountApiFp.accountFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Login a user with username/email and password.
         * @param credentials
         * @param include Related objects to include in the response. See the description of return value for more details.
         */
        accountLogin(params, options) {
            return exports.AccountApiFp.accountLogin(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Logout a user with access token.
         */
        accountLogout(options) {
            return exports.AccountApiFp.accountLogout(options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountPatchOrCreate(params, options) {
            return exports.AccountApiFp.accountPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts accessTokens of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeCountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts todos of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountTodos(params, options) {
            return exports.AccountApiFp.accountPrototypeCountTodos(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in accessTokens of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in todos of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateTodos(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateTodos(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all accessTokens of this model.
         * @param id Account id
         */
        accountPrototypeDeleteAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all todos of this model.
         * @param id Account id
         */
        accountPrototypeDeleteTodos(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteTodos(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeDestroyByIdAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for todos.
         * @param id Account id
         * @param fk Foreign key for todos
         */
        accountPrototypeDestroyByIdTodos(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdTodos(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeFindByIdAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for todos.
         * @param id Account id
         * @param fk Foreign key for todos
         */
        accountPrototypeFindByIdTodos(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdTodos(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries accessTokens of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeGetAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries todos of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetTodos(params, options) {
            return exports.AccountApiFp.accountPrototypeGetTodos(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Account id
         * @param data An object of model property name/value pairs
         */
        accountPrototypePatchAttributes(params, options) {
            return exports.AccountApiFp.accountPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         * @param data
         */
        accountPrototypeUpdateByIdAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for todos.
         * @param id Account id
         * @param fk Foreign key for todos
         * @param data
         */
        accountPrototypeUpdateByIdTodos(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdTodos(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param id Account id
         */
        accountPrototypeVerify(params, options) {
            return exports.AccountApiFp.accountPrototypeVerify(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPostAccountsidReplace(params, options) {
            return exports.AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPutAccountsid(params, options) {
            return exports.AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
            return exports.AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePutAccounts(params, options) {
            return exports.AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Reset password for a user with email.
         * @param options
         */
        accountResetPassword(params, options) {
            return exports.AccountApiFp.accountResetPassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Reset user's password via a password-reset token.
         * @param newPassword
         */
        accountSetPassword(params, options) {
            return exports.AccountApiFp.accountSetPassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpdateAll(params, options) {
            return exports.AccountApiFp.accountUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpsertWithWhere(params, options) {
            return exports.AccountApiFp.accountUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
/**
 * TodoApi - fetch parameter creator
 */
exports.TodoApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    todoCount(params, options) {
        const baseUrl = `/Todos/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    todoCreate(params, options) {
        const baseUrl = `/Todos`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    todoCreateChangeStreamGetTodosChangeStream(params, options) {
        const baseUrl = `/Todos/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    todoCreateChangeStreamPostTodosChangeStream(params, options) {
        const baseUrl = `/Todos/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    todoDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoDeleteById");
        }
        const baseUrl = `/Todos/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    todoExistsGetTodosidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoExistsGetTodosidExists");
        }
        const baseUrl = `/Todos/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    todoExistsHeadTodosid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoExistsHeadTodosid");
        }
        const baseUrl = `/Todos/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    todoFind(params, options) {
        const baseUrl = `/Todos`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    todoFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoFindById");
        }
        const baseUrl = `/Todos/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    todoFindOne(params, options) {
        const baseUrl = `/Todos/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoPatchOrCreate(params, options) {
        const baseUrl = `/Todos`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary copy
     * @param id Todo id
     * @param customName
     */
    todoPrototypeCopy(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoPrototypeCopy");
        }
        const baseUrl = `/Todos/{id}/copy`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "customName": params["customName"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts todoDetails of Todo.
     * @param id Todo id
     * @param where Criteria to match model instances
     */
    todoPrototypeCountTodoDetails(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoPrototypeCountTodoDetails");
        }
        const baseUrl = `/Todos/{id}/todoDetails/count`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in todoDetails of this model.
     * @param id Todo id
     * @param data
     */
    todoPrototypeCreateTodoDetails(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoPrototypeCreateTodoDetails");
        }
        const baseUrl = `/Todos/{id}/todoDetails`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all todoDetails of this model.
     * @param id Todo id
     */
    todoPrototypeDeleteTodoDetails(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoPrototypeDeleteTodoDetails");
        }
        const baseUrl = `/Todos/{id}/todoDetails`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for todoDetails.
     * @param id Todo id
     * @param fk Foreign key for todoDetails
     */
    todoPrototypeDestroyByIdTodoDetails(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoPrototypeDestroyByIdTodoDetails");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling todoPrototypeDestroyByIdTodoDetails");
        }
        const baseUrl = `/Todos/{id}/todoDetails/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for todoDetails.
     * @param id Todo id
     * @param fk Foreign key for todoDetails
     */
    todoPrototypeFindByIdTodoDetails(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoPrototypeFindByIdTodoDetails");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling todoPrototypeFindByIdTodoDetails");
        }
        const baseUrl = `/Todos/{id}/todoDetails/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Todo id
     * @param refresh
     */
    todoPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoPrototypeGetAccount");
        }
        const baseUrl = `/Todos/{id}/account`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries todoDetails of Todo.
     * @param id Todo id
     * @param filter
     */
    todoPrototypeGetTodoDetails(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoPrototypeGetTodoDetails");
        }
        const baseUrl = `/Todos/{id}/todoDetails`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Todo id
     * @param data An object of model property name/value pairs
     */
    todoPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoPrototypePatchAttributes");
        }
        const baseUrl = `/Todos/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for todoDetails.
     * @param id Todo id
     * @param fk Foreign key for todoDetails
     * @param data
     */
    todoPrototypeUpdateByIdTodoDetails(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoPrototypeUpdateByIdTodoDetails");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling todoPrototypeUpdateByIdTodoDetails");
        }
        const baseUrl = `/Todos/{id}/todoDetails/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    todoReplaceByIdPostTodosidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoReplaceByIdPostTodosidReplace");
        }
        const baseUrl = `/Todos/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    todoReplaceByIdPutTodosid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoReplaceByIdPutTodosid");
        }
        const baseUrl = `/Todos/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoReplaceOrCreatePostTodosReplaceOrCreate(params, options) {
        const baseUrl = `/Todos/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoReplaceOrCreatePutTodos(params, options) {
        const baseUrl = `/Todos`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    todoUpdateAll(params, options) {
        const baseUrl = `/Todos/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    todoUpsertWithWhere(params, options) {
        const baseUrl = `/Todos/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * TodoApi - functional programming interface
 */
exports.TodoApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    todoCount(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    todoCreate(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    todoCreateChangeStreamGetTodosChangeStream(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoCreateChangeStreamGetTodosChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    todoCreateChangeStreamPostTodosChangeStream(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoCreateChangeStreamPostTodosChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    todoDeleteById(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    todoExistsGetTodosidExists(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoExistsGetTodosidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    todoExistsHeadTodosid(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoExistsHeadTodosid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    todoFind(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    todoFindById(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    todoFindOne(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoPatchOrCreate(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary copy
     * @param id Todo id
     * @param customName
     */
    todoPrototypeCopy(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoPrototypeCopy(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts todoDetails of Todo.
     * @param id Todo id
     * @param where Criteria to match model instances
     */
    todoPrototypeCountTodoDetails(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoPrototypeCountTodoDetails(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in todoDetails of this model.
     * @param id Todo id
     * @param data
     */
    todoPrototypeCreateTodoDetails(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoPrototypeCreateTodoDetails(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all todoDetails of this model.
     * @param id Todo id
     */
    todoPrototypeDeleteTodoDetails(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoPrototypeDeleteTodoDetails(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for todoDetails.
     * @param id Todo id
     * @param fk Foreign key for todoDetails
     */
    todoPrototypeDestroyByIdTodoDetails(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoPrototypeDestroyByIdTodoDetails(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for todoDetails.
     * @param id Todo id
     * @param fk Foreign key for todoDetails
     */
    todoPrototypeFindByIdTodoDetails(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoPrototypeFindByIdTodoDetails(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Todo id
     * @param refresh
     */
    todoPrototypeGetAccount(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries todoDetails of Todo.
     * @param id Todo id
     * @param filter
     */
    todoPrototypeGetTodoDetails(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoPrototypeGetTodoDetails(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Todo id
     * @param data An object of model property name/value pairs
     */
    todoPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for todoDetails.
     * @param id Todo id
     * @param fk Foreign key for todoDetails
     * @param data
     */
    todoPrototypeUpdateByIdTodoDetails(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoPrototypeUpdateByIdTodoDetails(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    todoReplaceByIdPostTodosidReplace(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoReplaceByIdPostTodosidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    todoReplaceByIdPutTodosid(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoReplaceByIdPutTodosid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoReplaceOrCreatePostTodosReplaceOrCreate(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoReplaceOrCreatePostTodosReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoReplaceOrCreatePutTodos(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoReplaceOrCreatePutTodos(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    todoUpdateAll(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    todoUpsertWithWhere(params, options) {
        const fetchArgs = exports.TodoApiFetchParamCreator.todoUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * TodoApi - object-oriented interface
 */
class TodoApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    todoCount(params, options) {
        return exports.TodoApiFp.todoCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    todoCreate(params, options) {
        return exports.TodoApiFp.todoCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    todoCreateChangeStreamGetTodosChangeStream(params, options) {
        return exports.TodoApiFp.todoCreateChangeStreamGetTodosChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    todoCreateChangeStreamPostTodosChangeStream(params, options) {
        return exports.TodoApiFp.todoCreateChangeStreamPostTodosChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    todoDeleteById(params, options) {
        return exports.TodoApiFp.todoDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    todoExistsGetTodosidExists(params, options) {
        return exports.TodoApiFp.todoExistsGetTodosidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    todoExistsHeadTodosid(params, options) {
        return exports.TodoApiFp.todoExistsHeadTodosid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    todoFind(params, options) {
        return exports.TodoApiFp.todoFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    todoFindById(params, options) {
        return exports.TodoApiFp.todoFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    todoFindOne(params, options) {
        return exports.TodoApiFp.todoFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoPatchOrCreate(params, options) {
        return exports.TodoApiFp.todoPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary copy
     * @param id Todo id
     * @param customName
     */
    todoPrototypeCopy(params, options) {
        return exports.TodoApiFp.todoPrototypeCopy(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts todoDetails of Todo.
     * @param id Todo id
     * @param where Criteria to match model instances
     */
    todoPrototypeCountTodoDetails(params, options) {
        return exports.TodoApiFp.todoPrototypeCountTodoDetails(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in todoDetails of this model.
     * @param id Todo id
     * @param data
     */
    todoPrototypeCreateTodoDetails(params, options) {
        return exports.TodoApiFp.todoPrototypeCreateTodoDetails(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all todoDetails of this model.
     * @param id Todo id
     */
    todoPrototypeDeleteTodoDetails(params, options) {
        return exports.TodoApiFp.todoPrototypeDeleteTodoDetails(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for todoDetails.
     * @param id Todo id
     * @param fk Foreign key for todoDetails
     */
    todoPrototypeDestroyByIdTodoDetails(params, options) {
        return exports.TodoApiFp.todoPrototypeDestroyByIdTodoDetails(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for todoDetails.
     * @param id Todo id
     * @param fk Foreign key for todoDetails
     */
    todoPrototypeFindByIdTodoDetails(params, options) {
        return exports.TodoApiFp.todoPrototypeFindByIdTodoDetails(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Todo id
     * @param refresh
     */
    todoPrototypeGetAccount(params, options) {
        return exports.TodoApiFp.todoPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries todoDetails of Todo.
     * @param id Todo id
     * @param filter
     */
    todoPrototypeGetTodoDetails(params, options) {
        return exports.TodoApiFp.todoPrototypeGetTodoDetails(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Todo id
     * @param data An object of model property name/value pairs
     */
    todoPrototypePatchAttributes(params, options) {
        return exports.TodoApiFp.todoPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for todoDetails.
     * @param id Todo id
     * @param fk Foreign key for todoDetails
     * @param data
     */
    todoPrototypeUpdateByIdTodoDetails(params, options) {
        return exports.TodoApiFp.todoPrototypeUpdateByIdTodoDetails(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    todoReplaceByIdPostTodosidReplace(params, options) {
        return exports.TodoApiFp.todoReplaceByIdPostTodosidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    todoReplaceByIdPutTodosid(params, options) {
        return exports.TodoApiFp.todoReplaceByIdPutTodosid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoReplaceOrCreatePostTodosReplaceOrCreate(params, options) {
        return exports.TodoApiFp.todoReplaceOrCreatePostTodosReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoReplaceOrCreatePutTodos(params, options) {
        return exports.TodoApiFp.todoReplaceOrCreatePutTodos(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    todoUpdateAll(params, options) {
        return exports.TodoApiFp.todoUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    todoUpsertWithWhere(params, options) {
        return exports.TodoApiFp.todoUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.TodoApi = TodoApi;
;
/**
 * TodoApi - factory interface
 */
exports.TodoApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        todoCount(params, options) {
            return exports.TodoApiFp.todoCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        todoCreate(params, options) {
            return exports.TodoApiFp.todoCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        todoCreateChangeStreamGetTodosChangeStream(params, options) {
            return exports.TodoApiFp.todoCreateChangeStreamGetTodosChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        todoCreateChangeStreamPostTodosChangeStream(params, options) {
            return exports.TodoApiFp.todoCreateChangeStreamPostTodosChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        todoDeleteById(params, options) {
            return exports.TodoApiFp.todoDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        todoExistsGetTodosidExists(params, options) {
            return exports.TodoApiFp.todoExistsGetTodosidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        todoExistsHeadTodosid(params, options) {
            return exports.TodoApiFp.todoExistsHeadTodosid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        todoFind(params, options) {
            return exports.TodoApiFp.todoFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        todoFindById(params, options) {
            return exports.TodoApiFp.todoFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        todoFindOne(params, options) {
            return exports.TodoApiFp.todoFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        todoPatchOrCreate(params, options) {
            return exports.TodoApiFp.todoPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary copy
         * @param id Todo id
         * @param customName
         */
        todoPrototypeCopy(params, options) {
            return exports.TodoApiFp.todoPrototypeCopy(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts todoDetails of Todo.
         * @param id Todo id
         * @param where Criteria to match model instances
         */
        todoPrototypeCountTodoDetails(params, options) {
            return exports.TodoApiFp.todoPrototypeCountTodoDetails(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in todoDetails of this model.
         * @param id Todo id
         * @param data
         */
        todoPrototypeCreateTodoDetails(params, options) {
            return exports.TodoApiFp.todoPrototypeCreateTodoDetails(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all todoDetails of this model.
         * @param id Todo id
         */
        todoPrototypeDeleteTodoDetails(params, options) {
            return exports.TodoApiFp.todoPrototypeDeleteTodoDetails(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for todoDetails.
         * @param id Todo id
         * @param fk Foreign key for todoDetails
         */
        todoPrototypeDestroyByIdTodoDetails(params, options) {
            return exports.TodoApiFp.todoPrototypeDestroyByIdTodoDetails(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for todoDetails.
         * @param id Todo id
         * @param fk Foreign key for todoDetails
         */
        todoPrototypeFindByIdTodoDetails(params, options) {
            return exports.TodoApiFp.todoPrototypeFindByIdTodoDetails(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id Todo id
         * @param refresh
         */
        todoPrototypeGetAccount(params, options) {
            return exports.TodoApiFp.todoPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries todoDetails of Todo.
         * @param id Todo id
         * @param filter
         */
        todoPrototypeGetTodoDetails(params, options) {
            return exports.TodoApiFp.todoPrototypeGetTodoDetails(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Todo id
         * @param data An object of model property name/value pairs
         */
        todoPrototypePatchAttributes(params, options) {
            return exports.TodoApiFp.todoPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for todoDetails.
         * @param id Todo id
         * @param fk Foreign key for todoDetails
         * @param data
         */
        todoPrototypeUpdateByIdTodoDetails(params, options) {
            return exports.TodoApiFp.todoPrototypeUpdateByIdTodoDetails(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        todoReplaceByIdPostTodosidReplace(params, options) {
            return exports.TodoApiFp.todoReplaceByIdPostTodosidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        todoReplaceByIdPutTodosid(params, options) {
            return exports.TodoApiFp.todoReplaceByIdPutTodosid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        todoReplaceOrCreatePostTodosReplaceOrCreate(params, options) {
            return exports.TodoApiFp.todoReplaceOrCreatePostTodosReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        todoReplaceOrCreatePutTodos(params, options) {
            return exports.TodoApiFp.todoReplaceOrCreatePutTodos(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        todoUpdateAll(params, options) {
            return exports.TodoApiFp.todoUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        todoUpsertWithWhere(params, options) {
            return exports.TodoApiFp.todoUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
/**
 * TodoDetailApi - fetch parameter creator
 */
exports.TodoDetailApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    todoDetailCount(params, options) {
        const baseUrl = `/TodoDetails/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    todoDetailCreate(params, options) {
        const baseUrl = `/TodoDetails`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    todoDetailCreateChangeStreamGetTodoDetailsChangeStream(params, options) {
        const baseUrl = `/TodoDetails/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    todoDetailCreateChangeStreamPostTodoDetailsChangeStream(params, options) {
        const baseUrl = `/TodoDetails/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    todoDetailDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoDetailDeleteById");
        }
        const baseUrl = `/TodoDetails/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    todoDetailExistsGetTodoDetailsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoDetailExistsGetTodoDetailsidExists");
        }
        const baseUrl = `/TodoDetails/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    todoDetailExistsHeadTodoDetailsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoDetailExistsHeadTodoDetailsid");
        }
        const baseUrl = `/TodoDetails/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    todoDetailFind(params, options) {
        const baseUrl = `/TodoDetails`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    todoDetailFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoDetailFindById");
        }
        const baseUrl = `/TodoDetails/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    todoDetailFindOne(params, options) {
        const baseUrl = `/TodoDetails/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoDetailPatchOrCreate(params, options) {
        const baseUrl = `/TodoDetails`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation todo.
     * @param id TodoDetail id
     * @param refresh
     */
    todoDetailPrototypeGetTodo(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoDetailPrototypeGetTodo");
        }
        const baseUrl = `/TodoDetails/{id}/todo`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id TodoDetail id
     * @param data An object of model property name/value pairs
     */
    todoDetailPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoDetailPrototypePatchAttributes");
        }
        const baseUrl = `/TodoDetails/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    todoDetailReplaceByIdPostTodoDetailsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoDetailReplaceByIdPostTodoDetailsidReplace");
        }
        const baseUrl = `/TodoDetails/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    todoDetailReplaceByIdPutTodoDetailsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling todoDetailReplaceByIdPutTodoDetailsid");
        }
        const baseUrl = `/TodoDetails/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoDetailReplaceOrCreatePostTodoDetailsReplaceOrCreate(params, options) {
        const baseUrl = `/TodoDetails/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoDetailReplaceOrCreatePutTodoDetails(params, options) {
        const baseUrl = `/TodoDetails`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    todoDetailUpdateAll(params, options) {
        const baseUrl = `/TodoDetails/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    todoDetailUpsertWithWhere(params, options) {
        const baseUrl = `/TodoDetails/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * TodoDetailApi - functional programming interface
 */
exports.TodoDetailApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    todoDetailCount(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    todoDetailCreate(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    todoDetailCreateChangeStreamGetTodoDetailsChangeStream(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailCreateChangeStreamGetTodoDetailsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    todoDetailCreateChangeStreamPostTodoDetailsChangeStream(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailCreateChangeStreamPostTodoDetailsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    todoDetailDeleteById(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    todoDetailExistsGetTodoDetailsidExists(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailExistsGetTodoDetailsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    todoDetailExistsHeadTodoDetailsid(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailExistsHeadTodoDetailsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    todoDetailFind(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    todoDetailFindById(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    todoDetailFindOne(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoDetailPatchOrCreate(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation todo.
     * @param id TodoDetail id
     * @param refresh
     */
    todoDetailPrototypeGetTodo(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailPrototypeGetTodo(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id TodoDetail id
     * @param data An object of model property name/value pairs
     */
    todoDetailPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    todoDetailReplaceByIdPostTodoDetailsidReplace(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailReplaceByIdPostTodoDetailsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    todoDetailReplaceByIdPutTodoDetailsid(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailReplaceByIdPutTodoDetailsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoDetailReplaceOrCreatePostTodoDetailsReplaceOrCreate(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailReplaceOrCreatePostTodoDetailsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoDetailReplaceOrCreatePutTodoDetails(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailReplaceOrCreatePutTodoDetails(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    todoDetailUpdateAll(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    todoDetailUpsertWithWhere(params, options) {
        const fetchArgs = exports.TodoDetailApiFetchParamCreator.todoDetailUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * TodoDetailApi - object-oriented interface
 */
class TodoDetailApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    todoDetailCount(params, options) {
        return exports.TodoDetailApiFp.todoDetailCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    todoDetailCreate(params, options) {
        return exports.TodoDetailApiFp.todoDetailCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    todoDetailCreateChangeStreamGetTodoDetailsChangeStream(params, options) {
        return exports.TodoDetailApiFp.todoDetailCreateChangeStreamGetTodoDetailsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    todoDetailCreateChangeStreamPostTodoDetailsChangeStream(params, options) {
        return exports.TodoDetailApiFp.todoDetailCreateChangeStreamPostTodoDetailsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    todoDetailDeleteById(params, options) {
        return exports.TodoDetailApiFp.todoDetailDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    todoDetailExistsGetTodoDetailsidExists(params, options) {
        return exports.TodoDetailApiFp.todoDetailExistsGetTodoDetailsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    todoDetailExistsHeadTodoDetailsid(params, options) {
        return exports.TodoDetailApiFp.todoDetailExistsHeadTodoDetailsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    todoDetailFind(params, options) {
        return exports.TodoDetailApiFp.todoDetailFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    todoDetailFindById(params, options) {
        return exports.TodoDetailApiFp.todoDetailFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    todoDetailFindOne(params, options) {
        return exports.TodoDetailApiFp.todoDetailFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoDetailPatchOrCreate(params, options) {
        return exports.TodoDetailApiFp.todoDetailPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation todo.
     * @param id TodoDetail id
     * @param refresh
     */
    todoDetailPrototypeGetTodo(params, options) {
        return exports.TodoDetailApiFp.todoDetailPrototypeGetTodo(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id TodoDetail id
     * @param data An object of model property name/value pairs
     */
    todoDetailPrototypePatchAttributes(params, options) {
        return exports.TodoDetailApiFp.todoDetailPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    todoDetailReplaceByIdPostTodoDetailsidReplace(params, options) {
        return exports.TodoDetailApiFp.todoDetailReplaceByIdPostTodoDetailsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    todoDetailReplaceByIdPutTodoDetailsid(params, options) {
        return exports.TodoDetailApiFp.todoDetailReplaceByIdPutTodoDetailsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoDetailReplaceOrCreatePostTodoDetailsReplaceOrCreate(params, options) {
        return exports.TodoDetailApiFp.todoDetailReplaceOrCreatePostTodoDetailsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    todoDetailReplaceOrCreatePutTodoDetails(params, options) {
        return exports.TodoDetailApiFp.todoDetailReplaceOrCreatePutTodoDetails(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    todoDetailUpdateAll(params, options) {
        return exports.TodoDetailApiFp.todoDetailUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    todoDetailUpsertWithWhere(params, options) {
        return exports.TodoDetailApiFp.todoDetailUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.TodoDetailApi = TodoDetailApi;
;
/**
 * TodoDetailApi - factory interface
 */
exports.TodoDetailApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        todoDetailCount(params, options) {
            return exports.TodoDetailApiFp.todoDetailCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        todoDetailCreate(params, options) {
            return exports.TodoDetailApiFp.todoDetailCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        todoDetailCreateChangeStreamGetTodoDetailsChangeStream(params, options) {
            return exports.TodoDetailApiFp.todoDetailCreateChangeStreamGetTodoDetailsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        todoDetailCreateChangeStreamPostTodoDetailsChangeStream(params, options) {
            return exports.TodoDetailApiFp.todoDetailCreateChangeStreamPostTodoDetailsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        todoDetailDeleteById(params, options) {
            return exports.TodoDetailApiFp.todoDetailDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        todoDetailExistsGetTodoDetailsidExists(params, options) {
            return exports.TodoDetailApiFp.todoDetailExistsGetTodoDetailsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        todoDetailExistsHeadTodoDetailsid(params, options) {
            return exports.TodoDetailApiFp.todoDetailExistsHeadTodoDetailsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        todoDetailFind(params, options) {
            return exports.TodoDetailApiFp.todoDetailFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        todoDetailFindById(params, options) {
            return exports.TodoDetailApiFp.todoDetailFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        todoDetailFindOne(params, options) {
            return exports.TodoDetailApiFp.todoDetailFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        todoDetailPatchOrCreate(params, options) {
            return exports.TodoDetailApiFp.todoDetailPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation todo.
         * @param id TodoDetail id
         * @param refresh
         */
        todoDetailPrototypeGetTodo(params, options) {
            return exports.TodoDetailApiFp.todoDetailPrototypeGetTodo(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id TodoDetail id
         * @param data An object of model property name/value pairs
         */
        todoDetailPrototypePatchAttributes(params, options) {
            return exports.TodoDetailApiFp.todoDetailPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        todoDetailReplaceByIdPostTodoDetailsidReplace(params, options) {
            return exports.TodoDetailApiFp.todoDetailReplaceByIdPostTodoDetailsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        todoDetailReplaceByIdPutTodoDetailsid(params, options) {
            return exports.TodoDetailApiFp.todoDetailReplaceByIdPutTodoDetailsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        todoDetailReplaceOrCreatePostTodoDetailsReplaceOrCreate(params, options) {
            return exports.TodoDetailApiFp.todoDetailReplaceOrCreatePostTodoDetailsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        todoDetailReplaceOrCreatePutTodoDetails(params, options) {
            return exports.TodoDetailApiFp.todoDetailReplaceOrCreatePutTodoDetails(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        todoDetailUpdateAll(params, options) {
            return exports.TodoDetailApiFp.todoDetailUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        todoDetailUpsertWithWhere(params, options) {
            return exports.TodoDetailApiFp.todoDetailUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
//# sourceMappingURL=api.js.map